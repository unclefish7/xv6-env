### RISC-V 汇编问题答案 (answers-traps.txt)

1. **函数参数保存在哪些寄存器中？例如，main 调用 printf 时，13 保存在哪个寄存器中？**

   在 RISC-V 汇编中，寄存器 `a0` 到 `a7` 保存函数的参数。在 `main` 中调用 `printf` 时，值 13 保存在寄存器 `a2` 中。

   ```asm
   24:	4635                	li	a2,13    // 将 13 加载到 a2 中
   ```

2. **在 main 的汇编代码中，调用函数 f 的代码在哪里？调用 g 的代码在哪里？（提示：编译器可能会内联函数。）**

   在汇编代码中，`main` 调用 `f` 和 `g` 的代码被内联了。也就是说，编译器将这两个函数的代码直接插入到 `main` 函数中，而不是进行函数调用。

   ```asm
   14:	250d                	addiw	a0,a0,3  // f 函数和 g 函数都被内联为这一条指令
   ```

3. **printf 函数位于什么地址？**

   `printf` 函数的地址在运行时确定。以下指令：

   ```asm
   34:	5f8080e7          	jalr	1528(ra) # 628 <printf>   // 调用 printf，目标地址是 0x628
   ```

   表明 `printf` 位于地址 `0x628`。

4. **在 main 中的 jalr 到 printf 之后，ra 寄存器中的值是多少？**

   在 `jalr` 到 `printf` 之后，`ra`（返回地址）寄存器中的值将是 `jalr` 指令之后的指令地址，即 `0x38`（`li a0, 0` 的地址）。

   ```asm
   34:	5f8080e7          	jalr	1528(ra) # 628 <printf>   // ra 寄存器保存了下一条指令的地址 0x38
   ```

5. **运行以下代码，输出是什么？**

   ```c
   unsigned int i = 0x00646c72;
   printf("H%x Wo%s", 57616, &i);
   ```

   **输出：** `He110 WoWorld`

   **解释：**
   - `0x00646c72` 是字符串 `rld\0` 的小端表示。ASCII 值为：`r` (0x72), `l` (0x6c), `d` (0x64), `\0` (0x00)。
   - `57616` 的十六进制表示为 `e110`。

6. **如果 RISC-V 是大端序，为了产生相同的输出，你需要将 i 设置为什么值？是否需要将 57616 改为其他值？**

   如果 RISC-V 是大端序，你需要将 `i` 设置为 `0x726c6400` 才能产生相同的输出。而 `57616`（`e110` 的十六进制）不需要改变。

7. **在以下代码中，'y=' 后面将打印什么？为什么会发生这种情况？**

   ```c
   printf("x=%d y=%d", 3);
   ```

   **输出：**
   - `x=3 y=` 后面跟随一个未定义的值。

   **解释：**
   这是因为格式字符串期望有两个整数参数，但只提供了一个（`3`）。格式字符串中的第二个 `%d` 使 `printf` 从堆栈中读取下一个值，但这个值未被指定，因此导致未定义行为。

   ```asm
   26:	45b1                	li	a1,12    // 预期第二个参数，但实际没有提供
   ```
